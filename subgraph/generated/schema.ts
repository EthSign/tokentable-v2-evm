// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
    TypedMap,
    Entity,
    Value,
    ValueKind,
    store,
    Bytes,
    BigInt,
    BigDecimal
} from '@graphprotocol/graph-ts'

export class TokenTableSuiteDeployed extends Entity {
    constructor(id: string) {
        super()
        this.set('id', Value.fromString(id))
    }

    save(): void {
        let id = this.get('id')
        assert(
            id != null,
            'Cannot save TokenTableSuiteDeployed entity without an ID'
        )
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type TokenTableSuiteDeployed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set('TokenTableSuiteDeployed', id.toString(), this)
        }
    }

    static loadInBlock(id: string): TokenTableSuiteDeployed | null {
        return changetype<TokenTableSuiteDeployed | null>(
            store.get_in_block('TokenTableSuiteDeployed', id)
        )
    }

    static load(id: string): TokenTableSuiteDeployed | null {
        return changetype<TokenTableSuiteDeployed | null>(
            store.get('TokenTableSuiteDeployed', id)
        )
    }

    get id(): string {
        let value = this.get('id')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toString()
        }
    }

    set id(value: string) {
        this.set('id', Value.fromString(value))
    }

    get from(): Bytes {
        let value = this.get('from')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set from(value: Bytes) {
        this.set('from', Value.fromBytes(value))
    }

    get projectToken(): Bytes {
        let value = this.get('projectToken')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set projectToken(value: Bytes) {
        this.set('projectToken', Value.fromBytes(value))
    }

    get unlocker(): Bytes {
        let value = this.get('unlocker')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set unlocker(value: Bytes) {
        this.set('unlocker', Value.fromBytes(value))
    }

    get futureToken(): Bytes {
        let value = this.get('futureToken')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set futureToken(value: Bytes) {
        this.set('futureToken', Value.fromBytes(value))
    }

    get trackerToken(): Bytes {
        let value = this.get('trackerToken')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set trackerToken(value: Bytes) {
        this.set('trackerToken', Value.fromBytes(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get('blockTimestamp')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBigInt()
        }
    }

    set blockTimestamp(value: BigInt) {
        this.set('blockTimestamp', Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get('transactionHash')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set transactionHash(value: Bytes) {
        this.set('transactionHash', Value.fromBytes(value))
    }
}

export class TTEvent extends Entity {
    constructor(id: Bytes) {
        super()
        this.set('id', Value.fromBytes(id))
    }

    save(): void {
        let id = this.get('id')
        assert(id != null, 'Cannot save TTEvent entity without an ID')
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type TTEvent must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set('TTEvent', id.toBytes().toHexString(), this)
        }
    }

    static loadInBlock(id: Bytes): TTEvent | null {
        return changetype<TTEvent | null>(
            store.get_in_block('TTEvent', id.toHexString())
        )
    }

    static load(id: Bytes): TTEvent | null {
        return changetype<TTEvent | null>(
            store.get('TTEvent', id.toHexString())
        )
    }

    get id(): Bytes {
        let value = this.get('id')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set id(value: Bytes) {
        this.set('id', Value.fromBytes(value))
    }

    get from(): Bytes {
        let value = this.get('from')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set from(value: Bytes) {
        this.set('from', Value.fromBytes(value))
    }

    get timestamp(): BigInt {
        let value = this.get('timestamp')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBigInt()
        }
    }

    set timestamp(value: BigInt) {
        this.set('timestamp', Value.fromBigInt(value))
    }

    get event(): string {
        let value = this.get('event')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toString()
        }
    }

    set event(value: string) {
        this.set('event', Value.fromString(value))
    }

    get projectId(): string {
        let value = this.get('projectId')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toString()
        }
    }

    set projectId(value: string) {
        this.set('projectId', Value.fromString(value))
    }

    get presetId(): Bytes | null {
        let value = this.get('presetId')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBytes()
        }
    }

    set presetId(value: Bytes | null) {
        if (!value) {
            this.unset('presetId')
        } else {
            this.set('presetId', Value.fromBytes(<Bytes>value))
        }
    }

    get actualId(): BigInt | null {
        let value = this.get('actualId')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBigInt()
        }
    }

    set actualId(value: BigInt | null) {
        if (!value) {
            this.unset('actualId')
        } else {
            this.set('actualId', Value.fromBigInt(<BigInt>value))
        }
    }

    get someAddress(): Bytes | null {
        let value = this.get('someAddress')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBytes()
        }
    }

    set someAddress(value: Bytes | null) {
        if (!value) {
            this.unset('someAddress')
        } else {
            this.set('someAddress', Value.fromBytes(<Bytes>value))
        }
    }

    get someBytes(): Bytes | null {
        let value = this.get('someBytes')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBytes()
        }
    }

    set someBytes(value: Bytes | null) {
        if (!value) {
            this.unset('someBytes')
        } else {
            this.set('someBytes', Value.fromBytes(<Bytes>value))
        }
    }

    get amount(): BigInt | null {
        let value = this.get('amount')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBigInt()
        }
    }

    set amount(value: BigInt | null) {
        if (!value) {
            this.unset('amount')
        } else {
            this.set('amount', Value.fromBigInt(<BigInt>value))
        }
    }

    get amountUnlockedLeftover(): BigInt | null {
        let value = this.get('amountUnlockedLeftover')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBigInt()
        }
    }

    set amountUnlockedLeftover(value: BigInt | null) {
        if (!value) {
            this.unset('amountUnlockedLeftover')
        } else {
            this.set('amountUnlockedLeftover', Value.fromBigInt(<BigInt>value))
        }
    }

    get amountRefunded(): BigInt | null {
        let value = this.get('amountRefunded')
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toBigInt()
        }
    }

    set amountRefunded(value: BigInt | null) {
        if (!value) {
            this.unset('amountRefunded')
        } else {
            this.set('amountRefunded', Value.fromBigInt(<BigInt>value))
        }
    }

    get bool(): boolean {
        let value = this.get('bool')
        if (!value || value.kind == ValueKind.NULL) {
            return false
        } else {
            return value.toBoolean()
        }
    }

    set bool(value: boolean) {
        this.set('bool', Value.fromBoolean(value))
    }
}

export class Initialized extends Entity {
    constructor(id: Bytes) {
        super()
        this.set('id', Value.fromBytes(id))
    }

    save(): void {
        let id = this.get('id')
        assert(id != null, 'Cannot save Initialized entity without an ID')
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type Initialized must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set('Initialized', id.toBytes().toHexString(), this)
        }
    }

    static loadInBlock(id: Bytes): Initialized | null {
        return changetype<Initialized | null>(
            store.get_in_block('Initialized', id.toHexString())
        )
    }

    static load(id: Bytes): Initialized | null {
        return changetype<Initialized | null>(
            store.get('Initialized', id.toHexString())
        )
    }

    get id(): Bytes {
        let value = this.get('id')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set id(value: Bytes) {
        this.set('id', Value.fromBytes(value))
    }

    get version(): i32 {
        let value = this.get('version')
        if (!value || value.kind == ValueKind.NULL) {
            return 0
        } else {
            return value.toI32()
        }
    }

    set version(value: i32) {
        this.set('version', Value.fromI32(value))
    }

    get blockNumber(): BigInt {
        let value = this.get('blockNumber')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBigInt()
        }
    }

    set blockNumber(value: BigInt) {
        this.set('blockNumber', Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get('blockTimestamp')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBigInt()
        }
    }

    set blockTimestamp(value: BigInt) {
        this.set('blockTimestamp', Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get('transactionHash')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set transactionHash(value: Bytes) {
        this.set('transactionHash', Value.fromBytes(value))
    }
}

export class OwnershipTransferred extends Entity {
    constructor(id: Bytes) {
        super()
        this.set('id', Value.fromBytes(id))
    }

    save(): void {
        let id = this.get('id')
        assert(
            id != null,
            'Cannot save OwnershipTransferred entity without an ID'
        )
        if (id) {
            assert(
                id.kind == ValueKind.BYTES,
                `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set('OwnershipTransferred', id.toBytes().toHexString(), this)
        }
    }

    static loadInBlock(id: Bytes): OwnershipTransferred | null {
        return changetype<OwnershipTransferred | null>(
            store.get_in_block('OwnershipTransferred', id.toHexString())
        )
    }

    static load(id: Bytes): OwnershipTransferred | null {
        return changetype<OwnershipTransferred | null>(
            store.get('OwnershipTransferred', id.toHexString())
        )
    }

    get id(): Bytes {
        let value = this.get('id')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set id(value: Bytes) {
        this.set('id', Value.fromBytes(value))
    }

    get previousOwner(): Bytes {
        let value = this.get('previousOwner')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set previousOwner(value: Bytes) {
        this.set('previousOwner', Value.fromBytes(value))
    }

    get newOwner(): Bytes {
        let value = this.get('newOwner')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set newOwner(value: Bytes) {
        this.set('newOwner', Value.fromBytes(value))
    }

    get blockNumber(): BigInt {
        let value = this.get('blockNumber')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBigInt()
        }
    }

    set blockNumber(value: BigInt) {
        this.set('blockNumber', Value.fromBigInt(value))
    }

    get blockTimestamp(): BigInt {
        let value = this.get('blockTimestamp')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBigInt()
        }
    }

    set blockTimestamp(value: BigInt) {
        this.set('blockTimestamp', Value.fromBigInt(value))
    }

    get transactionHash(): Bytes {
        let value = this.get('transactionHash')
        if (!value || value.kind == ValueKind.NULL) {
            throw new Error('Cannot return null for a required field.')
        } else {
            return value.toBytes()
        }
    }

    set transactionHash(value: Bytes) {
        this.set('transactionHash', Value.fromBytes(value))
    }
}
