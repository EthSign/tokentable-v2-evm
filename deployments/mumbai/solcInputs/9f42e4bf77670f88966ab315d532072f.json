{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"../ERC1967/ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] so that it can be accessed externally.\n *\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\n * the beacon to not upgrade the implementation maliciously.\n *\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\n * an inconsistent state where the beacon storage slot does not match the beacon address.\n */\ncontract BeaconProxy is Proxy {\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\n    address private immutable _beacon;\n\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\n        _beacon = beacon;\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Returns the beacon.\n     */\n    function _getBeacon() internal view virtual returns (address) {\n        return _beacon;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"./IBeacon.sol\";\nimport {Ownable} from \"../../access/Ownable.sol\";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev The `implementation` of the beacon is invalid.\n     */\n    error BeaconInvalidImplementation(address implementation);\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the initial owner who can upgrade the beacon.\n     */\n    constructor(address implementation_, address initialOwner) Ownable(initialOwner) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert BeaconInvalidImplementation(newImplementation);\n        }\n        _implementation = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/core/extensions/TTFTV2Gasless.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {TTFutureTokenV2} from \"../TTFutureTokenV2.sol\";\nimport {ITokenTableUnlockerV2} from \"../../interfaces/ITokenTableUnlockerV2.sol\";\nimport {CustomERC2771Context} from \"../../libraries/CustomERC2771Context.sol\";\n\ncontract TTFTV2Gasless is TTFutureTokenV2, CustomERC2771Context {\n    function setTrustedForwarder(address forwarder) public virtual override {\n        if (\n            _msgSenderERC721A() !=\n            ITokenTableUnlockerV2(authorizedMinter).owner()\n        ) revert NotPermissioned();\n        super.setTrustedForwarder(forwarder);\n    }\n\n    function _msgSenderERC721A()\n        internal\n        view\n        virtual\n        override\n        returns (address)\n    {\n        return _msgSender();\n    }\n}\n"
    },
    "contracts/core/extensions/TTUV2Gasless.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport {TokenTableUnlockerV2} from \"../TokenTableUnlockerV2.sol\";\nimport {CustomERC2771Context} from \"../../libraries/CustomERC2771Context.sol\";\n\ncontract TTUV2Gasless is TokenTableUnlockerV2, CustomERC2771Context {\n    function setTrustedForwarder(\n        address forwarder\n    ) public virtual override onlyOwner {\n        super.setTrustedForwarder(forwarder);\n    }\n\n    function _msgSender()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, CustomERC2771Context)\n        returns (address sender)\n    {\n        return CustomERC2771Context._msgSender();\n    }\n\n    function _msgData()\n        internal\n        view\n        virtual\n        override(ContextUpgradeable, CustomERC2771Context)\n        returns (bytes calldata)\n    {\n        return CustomERC2771Context._msgData();\n    }\n}\n"
    },
    "contracts/core/TokenTableUnlockerV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Actual, Preset} from \"../interfaces/TokenTableUnlockerV2DataModels.sol\";\nimport {ITokenTableUnlockerV2, IOwnable} from \"../interfaces/ITokenTableUnlockerV2.sol\";\nimport {ITTHook} from \"../interfaces/ITTHook.sol\";\nimport {ITTFutureTokenV2} from \"./TTFutureTokenV2.sol\";\nimport {TTUProjectTokenStorage} from \"./TTUProjectTokenStorage.sol\";\nimport {ITTUDeployer} from \"../interfaces/ITTUDeployer.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\n\ncontract TokenTableUnlockerV2 is\n    OwnableUpgradeable,\n    TTUProjectTokenStorage,\n    ITokenTableUnlockerV2,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    uint256 public constant override BIPS_PRECISION = 10 ** 4; // down to 0.01%\n\n    ITTUDeployer public override deployer;\n    ITTFutureTokenV2 public override futureToken;\n    ITTHook public override hook;\n    address public override claimingDelegate;\n    bool public override isCancelable;\n    bool public override isHookable;\n    bool public override isWithdrawable;\n\n    mapping(bytes32 => Preset) internal _presets;\n    mapping(uint256 => Actual) public actuals;\n    mapping(uint256 => uint256)\n        public\n        override pendingAmountClaimableForCancelledActuals;\n\n    constructor() {\n        if (block.chainid != 33133) {\n            _disableInitializers();\n        }\n    }\n\n    function initialize(\n        address projectToken,\n        address futureToken_,\n        address deployer_,\n        bool isCancelable_,\n        bool isHookable_,\n        bool isWithdrawable_\n    ) external override initializer {\n        __Ownable_init_unchained(_msgSender());\n        _initializeSE(projectToken);\n        futureToken = ITTFutureTokenV2(futureToken_);\n        deployer = ITTUDeployer(deployer_);\n        __ReentrancyGuard_init_unchained();\n        claimingDelegate = owner();\n        isCancelable = isCancelable_;\n        isHookable = isHookable_;\n        isWithdrawable = isWithdrawable_;\n    }\n\n    // solhint-disable-next-line ordering\n    function createPresets(\n        bytes32[] memory presetIds,\n        Preset[] memory presets,\n        uint256 batchId\n    ) external virtual override onlyOwner {\n        for (uint256 i = 0; i < presetIds.length; i++) {\n            _createPreset(presetIds[i], presets[i], batchId);\n        }\n        _callHook(TokenTableUnlockerV2.createPresets.selector, msg.data);\n    }\n\n    function createActuals(\n        address[] memory recipients,\n        Actual[] memory actuals_,\n        uint256 batchId\n    ) external virtual override onlyOwner {\n        for (uint256 i = 0; i < recipients.length; i++) {\n            _createActual(recipients[i], actuals_[i], batchId);\n        }\n        _callHook(this.createActuals.selector, msg.data);\n    }\n\n    function withdrawDeposit(\n        uint256 amount\n    ) external virtual override onlyOwner {\n        if (!isWithdrawable) revert NotPermissioned();\n        IERC20(getProjectToken()).safeTransfer(_msgSender(), amount);\n        emit TokensWithdrawn(_msgSender(), amount);\n        _callHook(TokenTableUnlockerV2.withdrawDeposit.selector, msg.data);\n    }\n\n    function claim(\n        uint256[] calldata actualIds,\n        address[] calldata claimTos,\n        uint256 batchId\n    ) external virtual override nonReentrant {\n        for (uint256 i = 0; i < actualIds.length; i++) {\n            if (futureToken.ownerOf(actualIds[i]) != _msgSender()) {\n                revert NotPermissioned();\n            }\n            _claim(actualIds[i], claimTos[i], batchId);\n        }\n        _callHook(TokenTableUnlockerV2.claim.selector, msg.data);\n    }\n\n    function delegateClaim(\n        uint256[] calldata actualIds,\n        uint256 batchId\n    ) external virtual override nonReentrant {\n        if (_msgSender() != claimingDelegate) revert NotPermissioned();\n        for (uint256 i = 0; i < actualIds.length; i++) {\n            _claim(actualIds[i], address(0), batchId);\n        }\n        _callHook(TokenTableUnlockerV2.delegateClaim.selector, msg.data);\n    }\n\n    function cancel(\n        uint256[] calldata actualIds,\n        bool[] calldata shouldWipeClaimableBalance,\n        uint256 batchId\n    )\n        external\n        virtual\n        override\n        onlyOwner\n        returns (uint256[] memory pendingAmountClaimables)\n    {\n        if (!isCancelable) revert NotPermissioned();\n        pendingAmountClaimables = new uint256[](actualIds.length);\n        for (uint256 i = 0; i < actualIds.length; i++) {\n            uint256 actualId = actualIds[i];\n            (uint256 deltaAmountClaimable, ) = calculateAmountClaimable(\n                actualId\n            );\n            if (!shouldWipeClaimableBalance[i]) {\n                pendingAmountClaimableForCancelledActuals[\n                    actualId\n                ] += deltaAmountClaimable;\n            }\n            pendingAmountClaimables[i] = deltaAmountClaimable;\n            emit ActualCancelled(\n                actualId,\n                deltaAmountClaimable,\n                shouldWipeClaimableBalance[i],\n                batchId\n            );\n            delete actuals[actualId];\n        }\n        _callHook(TokenTableUnlockerV2.cancel.selector, msg.data);\n    }\n\n    function setHook(ITTHook hook_) external virtual override onlyOwner {\n        if (!isHookable) revert NotPermissioned();\n        hook = hook_;\n        _callHook(TokenTableUnlockerV2.setHook.selector, msg.data);\n    }\n\n    function setClaimingDelegate(\n        address delegate\n    ) external virtual override onlyOwner {\n        claimingDelegate = delegate;\n        emit ClaimingDelegateSet(delegate);\n    }\n\n    function disableCancel() external virtual override onlyOwner {\n        isCancelable = false;\n        emit CancelDisabled();\n        _callHook(TokenTableUnlockerV2.disableCancel.selector, msg.data);\n    }\n\n    function disableHook() external virtual override onlyOwner {\n        isHookable = false;\n        emit HookDisabled();\n        _callHook(TokenTableUnlockerV2.disableHook.selector, msg.data);\n        hook = ITTHook(address(0));\n    }\n\n    function disableWithdraw() external virtual override onlyOwner {\n        isWithdrawable = false;\n        emit WithdrawDisabled();\n        _callHook(TokenTableUnlockerV2.disableWithdraw.selector, msg.data);\n    }\n\n    function transferOwnership(\n        address newOwner\n    ) public override(IOwnable, OwnableUpgradeable) {\n        OwnableUpgradeable.transferOwnership(newOwner);\n        claimingDelegate = newOwner;\n        emit ClaimingDelegateSet(newOwner);\n    }\n\n    function renounceOwnership() public override(IOwnable, OwnableUpgradeable) {\n        OwnableUpgradeable.renounceOwnership();\n    }\n\n    function owner()\n        public\n        view\n        override(IOwnable, OwnableUpgradeable)\n        returns (address)\n    {\n        return OwnableUpgradeable.owner();\n    }\n\n    function _createPreset(\n        bytes32 presetId,\n        Preset memory preset,\n        uint256 batchId\n    ) internal virtual {\n        if (!_presetIsEmpty(_presets[presetId])) revert PresetExists();\n        if (!_presetHasValidFormat(preset)) revert InvalidPresetFormat();\n        _presets[presetId] = preset;\n        emit PresetCreated(presetId, batchId);\n    }\n\n    function _createActual(\n        address recipient,\n        Actual memory actual,\n        uint256 batchId\n    ) internal virtual {\n        uint256 actualId = futureToken.safeMint(recipient);\n        Preset storage preset = _presets[actual.presetId];\n        if (_presetIsEmpty(preset)) revert InvalidPresetFormat();\n        if (actual.amountClaimed >= actual.totalAmount)\n            revert InvalidSkipAmount();\n        actuals[actualId] = actual;\n        emit ActualCreated(actual.presetId, actualId, batchId);\n    }\n\n    function _claim(\n        uint256 actualId,\n        address overrideRecipient,\n        uint256 batchId\n    ) internal virtual {\n        uint256 deltaAmountClaimable;\n        address recipient;\n        if (overrideRecipient == address(0)) {\n            recipient = futureToken.ownerOf(actualId);\n        } else {\n            recipient = overrideRecipient;\n        }\n        deltaAmountClaimable = pendingAmountClaimableForCancelledActuals[\n            actualId\n        ];\n        if (deltaAmountClaimable != 0) {\n            pendingAmountClaimableForCancelledActuals[actualId] = 0;\n            IERC20(getProjectToken()).safeTransfer(\n                recipient,\n                deltaAmountClaimable\n            );\n        } else {\n            deltaAmountClaimable = _updateActualAndSend(actualId, recipient);\n        }\n        uint256 feesCharged = _chargeFees(deltaAmountClaimable);\n        emit TokensClaimed(\n            actualId,\n            _msgSender(),\n            recipient,\n            deltaAmountClaimable,\n            feesCharged,\n            batchId\n        );\n    }\n\n    function _callHook(\n        bytes4 selector,\n        bytes calldata context\n    ) internal virtual {\n        if (address(hook) == address(0)) return;\n        hook.didCall(selector, context, _msgSender());\n    }\n\n    // solhint-disable-next-line ordering\n    function getEncodedPreset(\n        bytes32 presetId\n    ) external view virtual override returns (bytes memory) {\n        Preset memory preset = _presets[presetId];\n        return\n            abi.encode(\n                preset.linearStartTimestampsRelative,\n                preset.linearEndTimestampRelative,\n                preset.linearBips,\n                preset.numOfUnlocksForEachLinear,\n                preset.stream\n            );\n    }\n\n    function version() external pure returns (string memory) {\n        return \"2.5.0\";\n    }\n\n    function calculateAmountClaimable(\n        uint256 actualId\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256 deltaAmountClaimable, uint256 updatedAmountClaimed)\n    {\n        uint256 tokenPrecisionDecimals = 10 ** 5;\n        Actual memory actual = actuals[actualId];\n        Preset memory preset = _presets[actual.presetId];\n        uint256 timePrecisionDecimals = preset.stream ? 10 ** 5 : 1;\n        uint256 i;\n        uint256 latestIncompleteLinearIndex;\n        if (block.timestamp < actual.startTimestampAbsolute)\n            return (0, actual.amountClaimed);\n        uint256 claimTimestampRelative = block.timestamp -\n            actual.startTimestampAbsolute;\n        for (i = 0; i < preset.linearStartTimestampsRelative.length; i++) {\n            if (\n                preset.linearStartTimestampsRelative[i] <=\n                claimTimestampRelative\n            ) {\n                latestIncompleteLinearIndex = i;\n            } else {\n                break;\n            }\n        }\n        // 1. calculate completed linear index claimables in bips\n        for (i = 0; i < latestIncompleteLinearIndex; i++) {\n            updatedAmountClaimed +=\n                preset.linearBips[i] *\n                tokenPrecisionDecimals;\n        }\n        // 2. calculate incomplete linear index claimable in bips\n        uint256 latestIncompleteLinearDuration = 0;\n        if (\n            latestIncompleteLinearIndex ==\n            preset.linearStartTimestampsRelative.length - 1\n        ) {\n            latestIncompleteLinearDuration =\n                preset.linearEndTimestampRelative -\n                preset.linearStartTimestampsRelative[\n                    preset.linearStartTimestampsRelative.length - 1\n                ];\n        } else {\n            latestIncompleteLinearDuration =\n                preset.linearStartTimestampsRelative[\n                    latestIncompleteLinearIndex + 1\n                ] -\n                preset.linearStartTimestampsRelative[\n                    latestIncompleteLinearIndex\n                ];\n        }\n        if (latestIncompleteLinearDuration == 0)\n            latestIncompleteLinearDuration = 1;\n        uint256 latestIncompleteLinearIntervalForEachUnlock = latestIncompleteLinearDuration /\n                preset.numOfUnlocksForEachLinear[latestIncompleteLinearIndex];\n        uint256 latestIncompleteLinearClaimableTimestampRelative = claimTimestampRelative -\n                preset.linearStartTimestampsRelative[\n                    latestIncompleteLinearIndex\n                ];\n        uint256 numOfClaimableUnlocksInIncompleteLinear = (latestIncompleteLinearClaimableTimestampRelative *\n                timePrecisionDecimals) /\n                latestIncompleteLinearIntervalForEachUnlock;\n        updatedAmountClaimed +=\n            (preset.linearBips[latestIncompleteLinearIndex] *\n                tokenPrecisionDecimals *\n                numOfClaimableUnlocksInIncompleteLinear) /\n            preset.numOfUnlocksForEachLinear[latestIncompleteLinearIndex] /\n            timePrecisionDecimals;\n        updatedAmountClaimed =\n            (updatedAmountClaimed * actual.totalAmount) /\n            BIPS_PRECISION /\n            tokenPrecisionDecimals;\n        if (updatedAmountClaimed > actual.totalAmount) {\n            updatedAmountClaimed = actual.totalAmount;\n        }\n        if (actual.amountClaimed > updatedAmountClaimed) {\n            deltaAmountClaimable = 0;\n        } else {\n            deltaAmountClaimable = updatedAmountClaimed - actual.amountClaimed;\n        }\n    }\n\n    function _updateActualAndSend(\n        uint256 actualId,\n        address recipient\n    ) internal returns (uint256 deltaAmountClaimable_) {\n        (\n            uint256 deltaAmountClaimable,\n            uint256 updatedAmountClaimed\n        ) = calculateAmountClaimable(actualId);\n        Actual storage actual = actuals[actualId];\n        actual.amountClaimed = updatedAmountClaimed;\n        IERC20(getProjectToken()).safeTransfer(recipient, deltaAmountClaimable);\n        deltaAmountClaimable_ = deltaAmountClaimable;\n    }\n\n    function _chargeFees(\n        uint256 amount\n    ) internal returns (uint256 feesCollected) {\n        if (\n            address(deployer) != address(0) &&\n            address(deployer.feeCollector()) != address(0)\n        ) {\n            feesCollected = deployer.feeCollector().getFee(\n                address(this),\n                amount\n            );\n            if (feesCollected > 0) {\n                IERC20(getProjectToken()).safeTransfer(\n                    deployer.feeCollector().owner(),\n                    feesCollected\n                );\n            }\n        }\n    }\n\n    function _presetIsEmpty(\n        Preset storage preset\n    ) internal view returns (bool) {\n        return\n            preset.linearBips.length *\n                preset.linearStartTimestampsRelative.length *\n                preset.numOfUnlocksForEachLinear.length *\n                preset.linearEndTimestampRelative ==\n            0;\n    }\n\n    function _presetHasValidFormat(\n        Preset memory preset\n    ) internal pure returns (bool) {\n        uint256 total;\n        for (uint256 i = 0; i < preset.linearBips.length; i++) {\n            total += preset.linearBips[i];\n        }\n        return\n            (total == BIPS_PRECISION) &&\n            (preset.linearBips.length ==\n                preset.linearStartTimestampsRelative.length) &&\n            (preset.linearStartTimestampsRelative[\n                preset.linearStartTimestampsRelative.length - 1\n            ] < preset.linearEndTimestampRelative) &&\n            (preset.numOfUnlocksForEachLinear.length ==\n                preset.linearStartTimestampsRelative.length);\n    }\n}\n"
    },
    "contracts/core/TTFutureTokenV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ITTFutureTokenV2} from \"../interfaces/ITTFutureTokenV2.sol\";\nimport {IERC721AUpgradeable} from \"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\";\nimport {ERC721AQueryableUpgradeable, ERC721AUpgradeable} from \"erc721a-upgradeable/contracts/extensions/ERC721AQueryableUpgradeable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ITokenTableUnlockerV2} from \"../interfaces/ITokenTableUnlockerV2.sol\";\n\n/**\n * @title TTFutureTokenV2\n * @author Jack Xu @ EthSign\n * @dev This is a redemption NFT minted to the stakeholder whenever an actual\n * unlocking schedule is created by a founder. The holder of a future token\n * can use it to claim unlocked tokens. A single instance of future token\n * corresponds to a single instance of unlocker. This token is transferrable.\n * The ID of this NFT is the ID of the actual unlocking schedule. The current\n * claimable amount can be determined by calling\n * TokenTableUnlockerV2.calculateAmountClaimable(uint256 actualId)\n */\ncontract TTFutureTokenV2 is ITTFutureTokenV2, ERC721AQueryableUpgradeable {\n    address public authorizedMinter;\n    bool public isTransferable;\n\n    // v2.0.1\n    string public baseUri;\n\n    constructor() {\n        if (block.chainid != 33133) {\n            _dummyInitialize();\n        }\n    }\n\n    function _dummyInitialize() internal initializerERC721A {}\n\n    // solhint-disable-next-line ordering\n    function initialize(\n        address projectToken,\n        bool isTransferable_\n    ) external override initializerERC721A {\n        __ERC721A_init_unchained(\n            string.concat(\"Future \", IERC20Metadata(projectToken).name()),\n            string.concat(\"FT-\", IERC20Metadata(projectToken).symbol())\n        );\n        isTransferable = isTransferable_;\n    }\n\n    /**\n     * @notice Sets who is authorized to mint future tokens.\n     * @dev This function can only be called once. It is called automatically\n     * when deployed using TTUDeployer. The authorized minter is usually the\n     * unlocker contract.\n     */\n    // solhint-disable-next-line ordering\n    function setAuthorizedMinterSingleUse(\n        address authorizedMinter_\n    ) external override {\n        if (authorizedMinter != address(0)) revert NotPermissioned();\n        authorizedMinter = authorizedMinter_;\n    }\n\n    /**\n     * @notice Mints a future token to an address.\n     * @dev This function can only be called by the authorized minter. A future\n     * token with tokenId == actualId is minted.\n     */\n    function safeMint(address to) external override returns (uint256 tokenId) {\n        if (_msgSenderERC721A() != authorizedMinter) revert NotPermissioned();\n        tokenId = _nextTokenId();\n        _safeMint(to, 1);\n    }\n\n    /**\n     * @dev Add a transfer lock\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override(ERC721AUpgradeable, IERC721AUpgradeable) {\n        if (!isTransferable) revert NotPermissioned();\n        super.transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Add a transfer lock\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override(ERC721AUpgradeable, IERC721AUpgradeable) {\n        if (!isTransferable) revert NotPermissioned();\n        super.safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    function setURI(string calldata uri) external {\n        if (\n            _msgSenderERC721A() !=\n            ITokenTableUnlockerV2(authorizedMinter).owner()\n        ) revert NotPermissioned();\n        baseUri = uri;\n        emit DidSetBaseURI(uri);\n    }\n\n    /**\n     * @notice Returns claim info for a given tokenId/actualId\n     * @dev We assume the authorized minter is an instance of TTUV2.\n     * @param tokenId The actual ID created in TTUV2.\n     * @return deltaAmountClaimable The amount of tokens claimable as of now.\n     * @return amountAlreadyClaimed The amount of tokens claimed as of now.\n     */\n    function getClaimInfo(\n        uint256 tokenId\n    )\n        external\n        view\n        override\n        returns (\n            uint256 deltaAmountClaimable,\n            uint256 amountAlreadyClaimed,\n            bool isCancelable\n        )\n    {\n        (\n            uint256 deltaAmountClaimable_,\n            uint256 updatedAmountClaimed_\n        ) = ITokenTableUnlockerV2(authorizedMinter).calculateAmountClaimable(\n                tokenId\n            );\n        deltaAmountClaimable = deltaAmountClaimable_;\n        amountAlreadyClaimed = updatedAmountClaimed_ - deltaAmountClaimable_;\n        isCancelable = ITokenTableUnlockerV2(authorizedMinter).isCancelable();\n    }\n\n    function version() external pure override returns (string memory) {\n        return \"2.5.0\";\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseUri;\n    }\n}\n"
    },
    "contracts/core/TTTrackerTokenV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ITTTrackerTokenV2} from \"../interfaces/ITTTrackerTokenV2.sol\";\nimport {TokenTableUnlockerV2} from \"./TokenTableUnlockerV2.sol\";\nimport {ITTFutureTokenV2} from \"../interfaces/ITTFutureTokenV2.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title TTTrackerTokenV2\n * @author Jack Xu @ EthSign\n * @dev An ERC20 token that represents the number of currently claimable\n * unlocked tokens. This token can be added into the investor's wallet,\n * making it easy for them to check on this information without having to\n * go through TokenTable's website.\n */\n// solhint-disable ordering\n// solhint-disable no-unused-vars\ncontract TTTrackerTokenV2 is ITTTrackerTokenV2, IERC20Metadata, Initializable {\n    TokenTableUnlockerV2 public ttuInstance;\n\n    constructor() {\n        if (block.chainid != 33133) {\n            _disableInitializers();\n        }\n    }\n\n    function initialize(address ttuInstance_) external override initializer {\n        ttuInstance = TokenTableUnlockerV2(ttuInstance_);\n    }\n\n    function name() external view returns (string memory) {\n        return\n            string.concat(\n                \"Tracker \",\n                IERC20Metadata(ttuInstance.getProjectToken()).name()\n            );\n    }\n\n    function symbol() external view returns (string memory) {\n        return\n            string.concat(\n                \"T-\",\n                IERC20Metadata(ttuInstance.getProjectToken()).symbol()\n            );\n    }\n\n    function decimals() external view returns (uint8) {\n        return IERC20Metadata(ttuInstance.getProjectToken()).decimals();\n    }\n\n    /**\n     * @dev Total number of tokens deposited into the unlocker awaiting claim.\n     */\n    function totalSupply() external view returns (uint256) {\n        return\n            IERC20Metadata(ttuInstance.getProjectToken()).balanceOf(\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Number of currently claimable tokens of the given address.\n     */\n    function balanceOf(address account) external view returns (uint256) {\n        uint256 amountClaimable;\n        ITTFutureTokenV2 nftInstance = ttuInstance.futureToken();\n        uint256[] memory tokenIdsOfOwner = nftInstance.tokensOfOwner(account);\n        for (uint256 i = 0; i < tokenIdsOfOwner.length; i++) {\n            (uint256 deltaAmountClaimable, ) = ttuInstance\n                .calculateAmountClaimable(tokenIdsOfOwner[i]);\n            amountClaimable += deltaAmountClaimable;\n        }\n        return amountClaimable;\n    }\n\n    /**\n     * @dev This operation is not allowed/implemented on purpose.\n     */\n    function transfer(address, uint256) external pure returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev This operation is not allowed/implemented on purpose.\n     */\n    function allowance(address, address) external pure returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev This operation is not allowed/implemented on purpose.\n     */\n    function approve(address, uint256) external pure returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev This operation is not allowed/implemented on purpose.\n     */\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external pure returns (bool) {\n        return false;\n    }\n\n    function version() external pure returns (string memory) {\n        return \"2.5.0\";\n    }\n}\n"
    },
    "contracts/core/TTUProjectTokenStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract TTUProjectTokenStorage is Initializable {\n    address private _projectToken;\n\n    error TokenSet();\n\n    function initializeProjectToken(address projectToken) public {\n        if (_projectToken != address(0)) revert TokenSet();\n        _projectToken = projectToken;\n    }\n\n    function getProjectToken() public view returns (address) {\n        return _projectToken;\n    }\n\n    function _initializeSE(address projectToken) internal onlyInitializing {\n        _projectToken = projectToken;\n    }\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ninterface IOwnable {\n    function renounceOwnership() external;\n\n    function transferOwnership(address newOwner) external;\n\n    function owner() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ITokenTableUnlockerV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IOwnable} from \"./IOwnable.sol\";\nimport {IVersionable} from \"./IVersionable.sol\";\nimport {Preset, Actual} from \"./TokenTableUnlockerV2DataModels.sol\";\nimport {ITTHook} from \"./ITTHook.sol\";\nimport {ITTUDeployer} from \"./ITTUDeployer.sol\";\nimport {ITTFutureTokenV2} from \"./ITTFutureTokenV2.sol\";\n\n/**\n * @title ITokenTableUnlockerV2\n * @author Jack Xu @ EthSign\n * @dev The lightweight interface for TokenTableUnlockerV2(.5.x), which handles token unlocking and distribution for TokenTable.\n */\nabstract contract ITokenTableUnlockerV2 is IOwnable, IVersionable {\n    event PresetCreated(bytes32 presetId, uint256 batchId);\n    event ActualCreated(bytes32 presetId, uint256 actualId, uint256 batchId);\n    event ActualCancelled(\n        uint256 actualId,\n        uint256 pendingAmountClaimable,\n        bool didWipeClaimableBalance,\n        uint256 batchId\n    );\n    event TokensClaimed(\n        uint256 actualId,\n        address caller,\n        address to,\n        uint256 amount,\n        uint256 feesCharged,\n        uint256 batchId\n    );\n    event TokensWithdrawn(address by, uint256 amount);\n    event ClaimingDelegateSet(address delegate);\n    event CancelDisabled();\n    event HookDisabled();\n    event WithdrawDisabled();\n\n    /**\n     * @dev 0x0ef8e8dc\n     */\n    error InvalidPresetFormat();\n    /**\n     * @dev 0x7cbb15b4\n     */\n    error PresetExists();\n    /**\n     * @dev 0xbd88ff7b\n     */\n    error PresetDoesNotExist();\n    /**\n     * @dev 0x78c0fc43\n     */\n    error InvalidSkipAmount();\n    /**\n     * @dev 0x7f63bd0f\n     */\n    error NotPermissioned();\n\n    /**\n     * @dev This contract should be deployed with `TTUDeployerLite`, which calls this function with the correct parameters.\n     * @param projectToken The address of the token that the founder intends to unlock and distribute.\n     * @param futureToken_ The address of the associated FutureToken.\n     * @param deployer_ The address of the deployer. It helps call the fee collector during claim.\n     * @param isCancelable_ If the founder is allowed to cancel schedules. Can be disabled later, but cannot be enabled again.\n     * @param isHookable_ If the founder is allowed to attach external hooks to function calls. Can be disabled later, but cannot be enabled again.\n     * @param isWithdrawable_ If the founder is allowed to withdraw deposited tokens. Can be disabled later, but cannot be enabled again.\n     */\n    function initialize(\n        address projectToken,\n        address futureToken_,\n        address deployer_,\n        bool isCancelable_,\n        bool isHookable_,\n        bool isWithdrawable_\n    ) external virtual;\n\n    /**\n     * @notice Creates an unlocking schedule preset template.\n     * @dev Emits `PresetCreated`. Only callable by the owner.\n     * @param presetIds These IDs can be the hashes of a plaintext preset names but really there is no restriction. Will revert if they already exist.\n     * @param presets An array of `Preset` structs.\n     * @param batchId Emitted as an event reserved for EthSign frontend use. This parameter has no effect on contract execution.\n     */\n    function createPresets(\n        bytes32[] calldata presetIds,\n        Preset[] memory presets,\n        uint256 batchId\n    ) external virtual;\n\n    /**\n     * @notice Creates an actual unlocking schedule based on a preset.\n     * @dev Emits `ActualCreated`. A FutureToken is minted in the process with `tokenId == actualId`.\n     * @param recipients An array of token recipients for the schedules. Note that claiming eligibility can be modified by transfering the corresponding FutureToken.\n     * @param actuals An array of `Actual` structs.\n     * @param batchId Emitted as an event reserved for EthSign frontend use. This parameter has no effect on contract execution.\n     */\n    function createActuals(\n        address[] calldata recipients,\n        Actual[] memory actuals,\n        uint256 batchId\n    ) external virtual;\n\n    /**\n     * @notice Withdraws existing deposit from the contract.\n     * @dev Emits `TokensWithdrawn`. Only callable by the owner.\n     * @param amount Amount of deposited funds the founder wishes to withdraw.\n     */\n    function withdrawDeposit(uint256 amount) external virtual;\n\n    /**\n     * @notice Claims claimable tokens for the specified schedules to the specified addresses respectively.\n     * @dev Emits `TokensClaimed`. Only callable by the FutureToken owner.\n     * @param actualIds The IDs of the unlocking schedules that we are trying to claim from.\n     * @param claimTos If we want to send the claimed tokens to an address other than the caller. To send the claimed tokens to the caller (default behavior), pass in `ethers.constants.AddressZero`.\n     * @param batchId Emitted as an event reserved for EthSign frontend use. This parameter has no effect on contract execution.\n     */\n    function claim(\n        uint256[] calldata actualIds,\n        address[] calldata claimTos,\n        uint256 batchId\n    ) external virtual;\n\n    /**\n     * @notice Claims claimable tokens for the specified schedules on behalf of recipients. Claimed tokens are sent to the schedule recipients.\n     * @dev Emits `TokensClaimed`. Only callable by the claiming delegate.\n     * @param actualIds The IDs of the unlocking schedules that we are trying to claim from on behalf of the recipients.\n     * @param batchId Emitted as an event reserved for EthSign frontend use. This parameter has no effect on contract execution.\n     */\n    function delegateClaim(\n        uint256[] calldata actualIds,\n        uint256 batchId\n    ) external virtual;\n\n    /**\n     * @notice Cancels an array of unlocking schedules effective immediately. Tokens not yet claimed but are already unlocked will be tallied.\n     * @dev Emits `ActualCancelled`. Only callable by the owner.\n     * @param actualIds The ID of the actual unlocking schedule that we want to cancel.\n     * @param shouldWipeClaimableBalance If the unlocked and claimable balance of the canceled schedule should be wiped. This is usually used to delete an erroneously created schedule that has already started unlocking.\n     * @param batchId Emitted as an event reserved for EthSign frontend use. This parameter has no effect on contract execution.\n     * @return pendingAmountClaimables Number of tokens eligible to be claimed by the affected stakeholders at the moment of cancellation.\n     */\n    function cancel(\n        uint256[] calldata actualIds,\n        bool[] calldata shouldWipeClaimableBalance,\n        uint256 batchId\n    ) external virtual returns (uint256[] memory pendingAmountClaimables);\n\n    /**\n     * @notice Sets the hook contract.\n     * @dev Only callable by the owner.\n     * @param hook The address of the `ITTHook` hook contract.\n     */\n    function setHook(ITTHook hook) external virtual;\n\n    /**\n     * @notice Sets the claiming delegate who can trigger claims on behalf of recipients.\n     * @dev Only callable by the owner.\n     */\n    function setClaimingDelegate(address delegate) external virtual;\n\n    /**\n     * @notice Permanently disables the `cancel()` function.\n     * @dev Only callable by the owner.\n     */\n    function disableCancel() external virtual;\n\n    /**\n     * @notice Permanently disables the hook.\n     * @dev Only callable by the owner.\n     */\n    function disableHook() external virtual;\n\n    /**\n     * @notice Permanently prevents the founder from withdrawing deposits.\n     * @dev Only callable by the owner.\n     */\n    function disableWithdraw() external virtual;\n\n    /**\n     * @return The deployer instance associated with this Unlocker.\n     */\n    function deployer() external view virtual returns (ITTUDeployer);\n\n    /**\n     * @return The FutureToken instance associated with this Unlocker.\n     */\n    function futureToken() external view virtual returns (ITTFutureTokenV2);\n\n    /**\n     * @return The external hook associated with this Unlocker.\n     */\n    function hook() external view virtual returns (ITTHook);\n\n    /**\n     * @return The claiming delegate who can trigger claims on behalf of schedule recipients.\n     */\n    function claimingDelegate() external view virtual returns (address);\n\n    /**\n     * @return If the founder is allowed to cancel schedules.\n     */\n    function isCancelable() external view virtual returns (bool);\n\n    /**\n     * @return If the founder can attach external hooks to function calls.\n     */\n    function isHookable() external view virtual returns (bool);\n\n    /**\n     * @return If the founder can withdraw deposited but unclaimed tokens.\n     */\n    function isWithdrawable() external view virtual returns (bool);\n\n    /**\n     * @param actualId The canceled schedule ID.\n     * @return The amount of tokens from canceled schedules that have been unlocked but unclaimed by the stakeholder.\n     */\n    function pendingAmountClaimableForCancelledActuals(\n        uint256 actualId\n    ) external view virtual returns (uint256);\n\n    /**\n     * @notice To decode in JS, use:\n     * ```js\n     *  ethers.utils.defaultAbiCoder.decode(\n     *      ['uint256[]', 'uint256', 'uint256[]', 'uint256[]', 'bool'],\n     *      encodedPreset\n     *  )\n     * ```\n     * @param presetId The ID of the preset we are trying to read.\n     * @return An ABI-encoded `Preset`, as nested objects cannot be returned directly in Solidity.\n     */\n    function getEncodedPreset(\n        bytes32 presetId\n    ) external view virtual returns (bytes memory);\n\n    /**\n     * @return The basis point precision of this Unlocker.\n     */\n    function BIPS_PRECISION() external pure virtual returns (uint256);\n\n    /**\n     * @notice Calculates the amount of unlocked tokens that have yet to be claimed in an actual unlocking schedule.\n     * @dev This is the most complex part of the smart contract. Quite a bit of calculations are performed here.\n     * @param actualId The ID of the actual unlocking schedule that we are working with.\n     * @return deltaAmountClaimable Amount of tokens claimable right now.\n     * @return updatedAmountClaimed New total amount of tokens claimed. This is the sum of all previously claimed tokens and `deltaAmountClaimable`.\n     */\n    function calculateAmountClaimable(\n        uint256 actualId\n    )\n        public\n        view\n        virtual\n        returns (uint256 deltaAmountClaimable, uint256 updatedAmountClaimed);\n}\n"
    },
    "contracts/interfaces/ITTFutureTokenV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IERC721AQueryableUpgradeable} from \"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\";\nimport {IVersionable} from \"./IVersionable.sol\";\n\n/**\n * @title ITTFutureTokenV2\n * @author Jack Xu @ EthSign\n * @dev The lightweight interface for TTFutureTokenV2(.5.x), which handles unlocking schedule ownership for TokenTable.\n */\ninterface ITTFutureTokenV2 is IERC721AQueryableUpgradeable, IVersionable {\n    event DidSetBaseURI(string newURI);\n\n    /**\n     * @dev 0x7f63bd0f\n     */\n    error NotPermissioned();\n\n    /**\n     * @dev This contract should be deployed with `TTUDeployerLite`, which calls this function with the correct parameters.\n     * @param projectToken The address of the token that the founder intends to unlock and distribute.\n     * @param isTransferable If the FutureTokens (aka schedules) can be transfered once minted.\n     */\n    function initialize(address projectToken, bool isTransferable) external;\n\n    /**\n     * @notice This contract should be deployed with `TTUDeployerLite`, which calls this function with the correct parameters.\n     * @dev This function can only be called once.\n     * @param authorizedMinter_ The address which is authorized to mint new FutureTokens. This is set to the corresponding Unlocker in the deployer.\n     */\n    function setAuthorizedMinterSingleUse(address authorizedMinter_) external;\n\n    /**\n     * @notice Safely mints a new FutureToken to the specified address.\n     * @dev This function can only be called by the authorized minter.\n     * @param to The recipient of the new FutureToken.\n     * @return tokenId The minted token ID (aka actual ID or schedule ID).\n     */\n    function safeMint(address to) external returns (uint256 tokenId);\n\n    /**\n     * @notice Updates the base URI.\n     * @dev This function can only be called by the owner of the authorized minter, which is usually the founder.\n     * @param uri The new base URI.\n     */\n    function setURI(string calldata uri) external;\n\n    /**\n     * @notice Gets information regarding the unlocking schedule associated with this FutureToken.\n     * @param tokenId The actual ID or schedule ID.\n     * @return deltaAmountClaimable The amount of unlocked and unclaimed funds currently eligible to be claimed by the owner of the given ID.\n     * @return amountAlreadyClaimed The amount of unlocked and claimed funds of the given ID.\n     * @return isCancelable If the schedule associated with this ID can be canceled by the founder.\n     */\n    function getClaimInfo(\n        uint256 tokenId\n    )\n        external\n        view\n        returns (\n            uint256 deltaAmountClaimable,\n            uint256 amountAlreadyClaimed,\n            bool isCancelable\n        );\n}\n"
    },
    "contracts/interfaces/ITTHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title ITTHook\n * @author Jack Xu @ EthSign\n */\ninterface ITTHook {\n    /**\n     * @notice Forwards the call context from the hooked contract.\n     * @dev Reverts within hooks will revert the hooked contract as well.\n     * @param selector The selector of the called function.\n     * @param context Encoded data from the called function.\n     * @param caller The caller of the hooked contract.\n     */\n    function didCall(\n        bytes4 selector,\n        bytes calldata context,\n        address caller\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITTTrackerTokenV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IVersionable} from \"./IVersionable.sol\";\n\ninterface ITTTrackerTokenV2 is IVersionable {\n    /**\n     * @dev This contract should be deployed with `TTUDeployerLite`, which calls this function with the correct parameters.\n     * @param ttuInstance_ The address of the corresponding Unlocker.\n     */\n    function initialize(address ttuInstance_) external;\n}\n"
    },
    "contracts/interfaces/ITTUDeployer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ITokenTableUnlockerV2} from \"./ITokenTableUnlockerV2.sol\";\nimport {ITTFutureTokenV2} from \"./ITTFutureTokenV2.sol\";\nimport {ITTTrackerTokenV2} from \"./ITTTrackerTokenV2.sol\";\nimport {ITTUFeeCollector} from \"./ITTUFeeCollector.sol\";\n\n/**\n * @title TTUDeployer\n * @author Jack Xu @ EthSign\n * @dev This is the deployer for all TokenTable core and proxy contracts. All initial setup and configuration is automatically done here.\n * To save gas and enable easy upgradeability, all deployed contracts are `Clone` or `BeaconProxy` instances.\n * You should avoid deploying TokenTable contracts individually unless you know what you're doing.\n */\ninterface ITTUDeployer {\n    event TTUDeployerInitialized(\n        address unlockerImpl,\n        address futureTokenImpl,\n        address trackerTokenImpl,\n        address beaconManagerImpl,\n        address feeCollector\n    );\n    event TokenTableSuiteDeployed(\n        address by,\n        string projectId,\n        address unlocker,\n        address futureToken,\n        address trackerToken\n    );\n    event FeeCollectorChanged(address feeCollector);\n\n    /**\n     * @dev 0xa6ef0ba1\n     */\n    error AlreadyDeployed();\n\n    /**\n     * @dev Exposes the fee collector variable.\n     * @return An instance of the fee collector.\n     */\n    function feeCollector() external returns (ITTUFeeCollector);\n\n    /**\n     * @notice Deploys and configures a new set of TokenTable products.\n     * @dev Emits `TokenTableSuiteDeployed`. Throws: `AlreadyDeployed`.\n     * @param projectToken The project token address.\n     * @param projectId A unique projectId, otherwise it will revert.\n     * @param isUpgradeable When set to false, a `Clone` instead of a `BeaconProxy` is created to prevent future upgradeability.\n     * @param isTransferable Allow FutureToken to be transferable.\n     * @param isCancelable Allow unlocking schedules to be cancelled in the Unlocker.\n     * @param isHookable Allow Unlocker to call an external hook.\n     * @param isWithdrawable Allow the founder to withdraw deposited funds.\n     */\n    function deployTTSuite(\n        address projectToken,\n        string calldata projectId,\n        bool isUpgradeable,\n        bool isTransferable,\n        bool isCancelable,\n        bool isHookable,\n        bool isWithdrawable\n    )\n        external\n        returns (ITokenTableUnlockerV2, ITTFutureTokenV2, ITTTrackerTokenV2);\n}\n"
    },
    "contracts/interfaces/ITTUFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {IOwnable} from \"./IOwnable.sol\";\nimport {IVersionable} from \"./IVersionable.sol\";\n\n/**\n * @title ITTUFeeCollector\n * @author Jack Xu @ EthSign\n * @dev This contract handles TokenTable service fee calculation.\n */\ninterface ITTUFeeCollector is IOwnable, IVersionable {\n    event DefaultFeeSet(uint256 bips);\n    event CustomFeeSet(address unlockerAddress, uint256 bips);\n\n    /**\n     * @notice Returns the amount of fees to collect.\n     * @param unlockerAddress The address of the Unlocker. Used to fetch pricing.\n     * @param tokenTransferred The number of tokens transferred.\n     * @return tokensCollected The number of tokens to collect as fees.\n     */\n    function getFee(\n        address unlockerAddress,\n        uint256 tokenTransferred\n    ) external view returns (uint256 tokensCollected);\n}\n"
    },
    "contracts/interfaces/IVersionable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title IVersionable\n * @author Jack Xu @ EthSign\n * @dev This interface is implemented by all major TokenTable contracts to keep track of their versioning for upgrade compatibility checks.\n */\ninterface IVersionable {\n    function version() external pure returns (string memory);\n}\n"
    },
    "contracts/interfaces/TokenTableUnlockerV2DataModels.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\n/**\n * @title TokenTableUnlockerV2DataModels.Preset\n * @author Jack Xu @ EthSign\n * @notice A `Preset` is an unlocking schedule template that contains information that's shared across all stakeholders within a single round.\n *\n * In this system, cliff unlocks are considered linear as well. This enables us to mix and match cliffs and linears at will, providing full customizability. Cliff waiting periods have a linear bip of 0 and cliff unlocking moments have a duration of 1 second.\n *\n * Note that all relative timestamps are relative to the absolute start timestamp. Absolute timestamps are standard UNIX epoch timestamps in seconds.\n *\n * `linearStartTimestampsRelative`: An array of start timestamps for each linear segment.\n * `linearEndTimestampRelative`: The timestamp that marks the end of the final linear segment.\n * `linearBips`: The basis point that is unlocked for each linear segment. Must add up to `TokenTableUnlockerV2.BIPS_PRECISION()`.\n * `numOfUnlocksForEachLinear`: The number of unlocks within each respective linear segment.\n * `stream`: If the tokens should unlock as a stream instead of a cliff at the end of linear segment subdivision.\n */\nstruct Preset {\n    uint256[] linearStartTimestampsRelative;\n    uint256 linearEndTimestampRelative;\n    uint256[] linearBips;\n    uint256[] numOfUnlocksForEachLinear;\n    bool stream;\n}\n\n/**\n * @title TokenTableUnlockerV2DataModels.Actual\n * @author Jack Xu @ EthSign\n * @notice An `Actual` is an actual unlocking schedule for a single stakeholder and builds on top of an existing preset. An actual contains information that is different from one stakeholder to the next.\n *\n * `presetId`: The ID of the `Preset` that this `Actual` references.\n * `startTimestampAbsolute`: The timestamp of when this unlocking schedule actually starts.\n * `amountClaimed`: The amount of tokens that have already been claimed by the recipient.\n * `totalAmount`: The maximum amount of tokens that the recipient can claim throughout the entire schedule.\n */\nstruct Actual {\n    bytes32 presetId;\n    uint256 startTimestampAbsolute;\n    uint256 amountClaimed;\n    uint256 totalAmount;\n}\n"
    },
    "contracts/libraries/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n// solhint-disable\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(\n                0x00,\n                or(\n                    shr(0xe8, shl(0x60, implementation)),\n                    0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000\n                )\n            )\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(\n                0x20,\n                or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3)\n            )\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(\n        address implementation,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(\n                0x00,\n                or(\n                    shr(0xe8, shl(0x60, implementation)),\n                    0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000\n                )\n            )\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(\n                0x20,\n                or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3)\n            )\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/libraries/CustomERC2771Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\npragma solidity ^0.8.20;\n\nabstract contract CustomERC2771Context {\n    address public trustedForwarder;\n\n    // @dev MUST override in implementation and make sure this is onlyOwner\n    function setTrustedForwarder(address forwarder) public virtual {\n        trustedForwarder = forwarder;\n    }\n\n    function isTrustedForwarder(\n        address forwarder\n    ) public view virtual returns (bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/proxy/TTUDeployerLite.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport {ITTUDeployer} from \"../interfaces/ITTUDeployer.sol\";\nimport {TTUV2BeaconManager} from \"./TTUV2BeaconManager.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ITokenTableUnlockerV2} from \"../interfaces/ITokenTableUnlockerV2.sol\";\nimport {ITTFutureTokenV2} from \"../interfaces/ITTFutureTokenV2.sol\";\nimport {ITTTrackerTokenV2} from \"../interfaces/ITTTrackerTokenV2.sol\";\nimport {ITTUFeeCollector} from \"../interfaces/ITTUFeeCollector.sol\";\nimport {BeaconProxy} from \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport {Clones} from \"../libraries/Clones.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IVersionable} from \"../interfaces/IVersionable.sol\";\n\ncontract TTUDeployerLite is ITTUDeployer, Ownable, IVersionable {\n    TTUV2BeaconManager public beaconManager;\n    ITTUFeeCollector public override feeCollector;\n    mapping(string => bool) public registry;\n\n    constructor() Ownable(_msgSender()) {}\n\n    function setBeaconManager(\n        TTUV2BeaconManager _beaconManager\n    ) external onlyOwner {\n        beaconManager = _beaconManager;\n    }\n\n    function setFeeCollector(\n        ITTUFeeCollector feeCollector_\n    ) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(address(feeCollector));\n    }\n\n    function deployTTSuite(\n        address projectToken,\n        string calldata projectId,\n        bool isUpgradeable,\n        bool isTransferable,\n        bool isCancelable,\n        bool isHookable,\n        bool isWithdrawable\n    )\n        external\n        returns (ITokenTableUnlockerV2, ITTFutureTokenV2, ITTTrackerTokenV2)\n    {\n        if (registry[projectId]) revert AlreadyDeployed();\n        registry[projectId] = true;\n\n        ITTFutureTokenV2 futureToken;\n        ITokenTableUnlockerV2 unlocker;\n        ITTTrackerTokenV2 trackerToken;\n        if (!isUpgradeable) {\n            futureToken = ITTFutureTokenV2(\n                Clones.clone(beaconManager.futureTokenBeacon().implementation())\n            );\n            futureToken.initialize(projectToken, isTransferable);\n            unlocker = ITokenTableUnlockerV2(\n                Clones.clone(beaconManager.unlockerBeacon().implementation())\n            );\n            unlocker.initialize(\n                projectToken,\n                address(futureToken),\n                address(this),\n                isCancelable,\n                isHookable,\n                isWithdrawable\n            );\n            trackerToken = ITTTrackerTokenV2(\n                Clones.clone(\n                    beaconManager.trackerTokenBeacon().implementation()\n                )\n            );\n            trackerToken.initialize(address(unlocker));\n        } else {\n            futureToken = ITTFutureTokenV2(\n                address(\n                    new BeaconProxy(\n                        address(beaconManager.futureTokenBeacon()),\n                        abi.encodeWithSelector(\n                            ITTFutureTokenV2.initialize.selector,\n                            projectToken,\n                            isTransferable\n                        )\n                    )\n                )\n            );\n            unlocker = ITokenTableUnlockerV2(\n                address(\n                    new BeaconProxy(\n                        address(beaconManager.unlockerBeacon()),\n                        abi.encodeWithSelector(\n                            ITokenTableUnlockerV2.initialize.selector,\n                            projectToken,\n                            futureToken,\n                            this,\n                            isCancelable,\n                            isHookable,\n                            isWithdrawable\n                        )\n                    )\n                )\n            );\n            trackerToken = ITTTrackerTokenV2(\n                address(\n                    new BeaconProxy(\n                        address(beaconManager.trackerTokenBeacon()),\n                        abi.encodeWithSelector(\n                            ITTTrackerTokenV2.initialize.selector,\n                            address(unlocker)\n                        )\n                    )\n                )\n            );\n        }\n        unlocker.transferOwnership(msg.sender);\n        futureToken.setAuthorizedMinterSingleUse(address(unlocker));\n        emit TokenTableSuiteDeployed(\n            msg.sender,\n            projectId,\n            address(unlocker),\n            address(futureToken),\n            address(trackerToken)\n        );\n        return (unlocker, futureToken, trackerToken);\n    }\n\n    function version() external pure returns (string memory) {\n        return \"2.5.0\";\n    }\n}\n"
    },
    "contracts/proxy/TTUV2BeaconManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.20;\n\nimport {UpgradeableBeacon} from \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IVersionable} from \"../interfaces/IVersionable.sol\";\n\n/**\n * @title TTUV2BeaconManager\n * @author Jack Xu @ EthSign\n * @dev This contract manages the upgradeable beacons that we use to seamlessly\n * upgrade TokenTableUnlocker, TTFutureToken, and TTTrackerToken on behalf of\n * our users in the future.\n *\n * This contract should be deployed using TTUDeployer.\n */\ncontract TTUV2BeaconManager is Ownable, IVersionable {\n    UpgradeableBeacon public immutable unlockerBeacon;\n    UpgradeableBeacon public immutable futureTokenBeacon;\n    UpgradeableBeacon public immutable trackerTokenBeacon;\n\n    constructor(\n        address unlockerImpl,\n        address futureTokenImpl,\n        address trackerTokenImpl\n    ) Ownable(_msgSender()) {\n        unlockerBeacon = new UpgradeableBeacon(unlockerImpl, address(this));\n        futureTokenBeacon = new UpgradeableBeacon(\n            futureTokenImpl,\n            address(this)\n        );\n        trackerTokenBeacon = new UpgradeableBeacon(\n            trackerTokenImpl,\n            address(this)\n        );\n    }\n\n    function upgradeUnlocker(address newImpl) external onlyOwner {\n        unlockerBeacon.upgradeTo(newImpl);\n    }\n\n    function upgradeFutureToken(address newImpl) external onlyOwner {\n        futureTokenBeacon.upgradeTo(newImpl);\n    }\n\n    function upgradePreviewToken(address newImpl) external onlyOwner {\n        trackerTokenBeacon.upgradeTo(newImpl);\n    }\n\n    function version() external pure returns (string memory) {\n        return \"2.0.1\";\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/ERC721A__Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable diamond facet contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\n\nimport {ERC721A__InitializableStorage} from './ERC721A__InitializableStorage.sol';\n\nabstract contract ERC721A__Initializable {\n    using ERC721A__InitializableStorage for ERC721A__InitializableStorage.Layout;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializerERC721A() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(\n            ERC721A__InitializableStorage.layout()._initializing\n                ? _isConstructor()\n                : !ERC721A__InitializableStorage.layout()._initialized,\n            'ERC721A__Initializable: contract is already initialized'\n        );\n\n        bool isTopLevelCall = !ERC721A__InitializableStorage.layout()._initializing;\n        if (isTopLevelCall) {\n            ERC721A__InitializableStorage.layout()._initializing = true;\n            ERC721A__InitializableStorage.layout()._initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            ERC721A__InitializableStorage.layout()._initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializingERC721A() {\n        require(\n            ERC721A__InitializableStorage.layout()._initializing,\n            'ERC721A__Initializable: contract is not initializing'\n        );\n        _;\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/ERC721A__InitializableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base storage for the  initialization function for upgradeable diamond facet contracts\n **/\n\nlibrary ERC721A__InitializableStorage {\n    struct Layout {\n        /*\n         * Indicates that the contract has been initialized.\n         */\n        bool _initialized;\n        /*\n         * Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256('ERC721A.contracts.storage.initializable.facet');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/ERC721AStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary ERC721AStorage {\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n    struct TokenApprovalRef {\n        address value;\n    }\n\n    struct Layout {\n        // =============================================================\n        //                            STORAGE\n        // =============================================================\n\n        // The next token ID to be minted.\n        uint256 _currentIndex;\n        // The number of tokens burned.\n        uint256 _burnCounter;\n        // Token name\n        string _name;\n        // Token symbol\n        string _symbol;\n        // Mapping from token ID to ownership details\n        // An empty struct value does not necessarily mean the token is unowned.\n        // See {_packedOwnershipOf} implementation for details.\n        //\n        // Bits Layout:\n        // - [0..159]   `addr`\n        // - [160..223] `startTimestamp`\n        // - [224]      `burned`\n        // - [225]      `nextInitialized`\n        // - [232..255] `extraData`\n        mapping(uint256 => uint256) _packedOwnerships;\n        // Mapping owner address to address data.\n        //\n        // Bits Layout:\n        // - [0..63]    `balance`\n        // - [64..127]  `numberMinted`\n        // - [128..191] `numberBurned`\n        // - [192..255] `aux`\n        mapping(address => uint256) _packedAddressData;\n        // Mapping from token ID to approved address.\n        mapping(uint256 => ERC721AStorage.TokenApprovalRef) _tokenApprovals;\n        // Mapping from owner to operator approvals\n        mapping(address => mapping(address => bool)) _operatorApprovals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT = keccak256('ERC721A.contracts.storage.ERC721A');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/ERC721AUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721AUpgradeable.sol';\nimport {ERC721AStorage} from './ERC721AStorage.sol';\nimport './ERC721A__Initializable.sol';\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721ReceiverUpgradeable {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721AUpgradeable is ERC721A__Initializable, IERC721AUpgradeable {\n    using ERC721AStorage for ERC721AStorage.Layout;\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    function __ERC721A_init(string memory name_, string memory symbol_) internal onlyInitializingERC721A {\n        __ERC721A_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721A_init_unchained(string memory name_, string memory symbol_) internal onlyInitializingERC721A {\n        ERC721AStorage.layout()._name = name_;\n        ERC721AStorage.layout()._symbol = symbol_;\n        ERC721AStorage.layout()._currentIndex = _startTokenId();\n    }\n\n    // =============================================================\n    //                   TOKEN COUNTING OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return ERC721AStorage.layout()._currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return ERC721AStorage.layout()._currentIndex - ERC721AStorage.layout()._burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return ERC721AStorage.layout()._currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view virtual returns (uint256) {\n        return ERC721AStorage.layout()._burnCounter;\n    }\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return ERC721AStorage.layout()._packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return\n            (ERC721AStorage.layout()._packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return\n            (ERC721AStorage.layout()._packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(ERC721AStorage.layout()._packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal virtual {\n        uint256 packed = ERC721AStorage.layout()._packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n        ERC721AStorage.layout()._packedAddressData[owner] = packed;\n    }\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() public view virtual override returns (string memory) {\n        return ERC721AStorage.layout()._name;\n    }\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return ERC721AStorage.layout()._symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, it can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(ERC721AStorage.layout()._packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal virtual {\n        if (ERC721AStorage.layout()._packedOwnerships[index] == 0) {\n            ERC721AStorage.layout()._packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\n        if (_startTokenId() <= tokenId) {\n            packed = ERC721AStorage.layout()._packedOwnerships[tokenId];\n            // If not burned.\n            if (packed & _BITMASK_BURNED == 0) {\n                // If the data at the starting slot does not exist, start the scan.\n                if (packed == 0) {\n                    if (tokenId >= ERC721AStorage.layout()._currentIndex) revert OwnerQueryForNonexistentToken();\n                    // Invariant:\n                    // There will always be an initialized ownership slot\n                    // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                    // before an unintialized ownership slot\n                    // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                    // Hence, `tokenId` will not underflow.\n                    //\n                    // We can directly compare the packed value.\n                    // If the address is zero, packed will be zero.\n                    for (;;) {\n                        unchecked {\n                            packed = ERC721AStorage.layout()._packedOwnerships[--tokenId];\n                        }\n                        if (packed == 0) continue;\n                        return packed;\n                    }\n                }\n                // Otherwise, the data exists and is not burned. We can skip the scan.\n                // This is possible because we have already achieved the target condition.\n                // This saves 2143 gas on transfers of initialized tokens.\n                return packed;\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }\n\n    // =============================================================\n    //                      APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     */\n    function approve(address to, uint256 tokenId) public payable virtual override {\n        _approve(to, tokenId, true);\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return ERC721AStorage.layout()._tokenApprovals[tokenId].value;\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        ERC721AStorage.layout()._operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return ERC721AStorage.layout()._operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return\n            _startTokenId() <= tokenId &&\n            tokenId < ERC721AStorage.layout()._currentIndex && // If within bounds,\n            ERC721AStorage.layout()._packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    /**\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n     */\n    function _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            // `msgSender == owner || msgSender == approvedAddress`.\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\n\n    /**\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\n     */\n    function _getApprovedSlotAndAddress(uint256 tokenId)\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        ERC721AStorage.TokenApprovalRef storage tokenApproval = ERC721AStorage.layout()._tokenApprovals[tokenId];\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --ERC721AStorage.layout()._packedAddressData[from]; // Updates: `balance -= 1`.\n            ++ERC721AStorage.layout()._packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            ERC721AStorage.layout()._packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (ERC721AStorage.layout()._packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != ERC721AStorage.layout()._currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        ERC721AStorage.layout()._packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token IDs\n     * are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token IDs\n     * have been transferred. This includes minting.\n     * And also called after one token has been burned.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * `from` - Previous owner of the given token ID.\n     * `to` - Target address that will receive the token.\n     * `tokenId` - Token ID to be transferred.\n     * `_data` - Optional data to send along with the call.\n     *\n     * Returns whether the call correctly returned the expected magic value.\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try\n            ERC721A__IERC721ReceiverUpgradeable(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data)\n        returns (bytes4 retval) {\n            return retval == ERC721A__IERC721ReceiverUpgradeable(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = ERC721AStorage.layout()._currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            ERC721AStorage.layout()._packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            ERC721AStorage.layout()._packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            ERC721AStorage.layout()._currentIndex = end;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * This function is intended for efficient minting only during contract creation.\n     *\n     * It emits only one {ConsecutiveTransfer} as defined in\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n     * instead of a sequence of {Transfer} event(s).\n     *\n     * Calling this function outside of contract creation WILL make your contract\n     * non-compliant with the ERC721 standard.\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {ConsecutiveTransfer} event.\n     */\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = ERC721AStorage.layout()._currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            ERC721AStorage.layout()._packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            ERC721AStorage.layout()._packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\n\n            ERC721AStorage.layout()._currentIndex = startTokenId + quantity;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * See {_mint}.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 end = ERC721AStorage.layout()._currentIndex;\n                uint256 index = end - quantity;\n                do {\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (index < end);\n                // Reentrancy protection.\n                if (ERC721AStorage.layout()._currentIndex != end) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, '');\n    }\n\n    // =============================================================\n    //                       APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_approve(to, tokenId, false)`.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _approve(to, tokenId, false);\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        bool approvalCheck\n    ) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        if (approvalCheck)\n            if (_msgSenderERC721A() != owner)\n                if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                    revert ApprovalCallerNotOwnerNorApproved();\n                }\n\n        ERC721AStorage.layout()._tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (approvalCheck) {\n            // The nested ifs save around 20+ gas over a compound boolean condition.\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            ERC721AStorage.layout()._packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            ERC721AStorage.layout()._packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (ERC721AStorage.layout()._packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != ERC721AStorage.layout()._currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        ERC721AStorage.layout()._packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            ERC721AStorage.layout()._burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\n        uint256 packed = ERC721AStorage.layout()._packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n        ERC721AStorage.layout()._packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) internal view virtual returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/extensions/ERC721AQueryableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721AQueryableUpgradeable.sol';\nimport '../ERC721AUpgradeable.sol';\nimport '../ERC721A__Initializable.sol';\n\n/**\n * @title ERC721AQueryable.\n *\n * @dev ERC721A subclass with convenience query functions.\n */\nabstract contract ERC721AQueryableUpgradeable is\n    ERC721A__Initializable,\n    ERC721AUpgradeable,\n    IERC721AQueryableUpgradeable\n{\n    function __ERC721AQueryable_init() internal onlyInitializingERC721A {\n        __ERC721AQueryable_init_unchained();\n    }\n\n    function __ERC721AQueryable_init_unchained() internal onlyInitializingERC721A {}\n\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) public view virtual override returns (TokenOwnership memory) {\n        TokenOwnership memory ownership;\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\n            return ownership;\n        }\n        ownership = _ownershipAt(tokenId);\n        if (ownership.burned) {\n            return ownership;\n        }\n        return _ownershipOf(tokenId);\n    }\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\n        external\n        view\n        virtual\n        override\n        returns (TokenOwnership[] memory)\n    {\n        unchecked {\n            uint256 tokenIdsLength = tokenIds.length;\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\n            for (uint256 i; i != tokenIdsLength; ++i) {\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\n            }\n            return ownerships;\n        }\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view virtual override returns (uint256[] memory) {\n        unchecked {\n            if (start >= stop) revert InvalidQueryRange();\n            uint256 tokenIdsIdx;\n            uint256 stopLimit = _nextTokenId();\n            // Set `start = max(start, _startTokenId())`.\n            if (start < _startTokenId()) {\n                start = _startTokenId();\n            }\n            // Set `stop = min(stop, stopLimit)`.\n            if (stop > stopLimit) {\n                stop = stopLimit;\n            }\n            uint256 tokenIdsMaxLength = balanceOf(owner);\n            // Set `tokenIdsMaxLength = min(balanceOf(owner), stop - start)`,\n            // to cater for cases where `balanceOf(owner)` is too big.\n            if (start < stop) {\n                uint256 rangeLength = stop - start;\n                if (rangeLength < tokenIdsMaxLength) {\n                    tokenIdsMaxLength = rangeLength;\n                }\n            } else {\n                tokenIdsMaxLength = 0;\n            }\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\n            if (tokenIdsMaxLength == 0) {\n                return tokenIds;\n            }\n            // We need to call `explicitOwnershipOf(start)`,\n            // because the slot at `start` may not be initialized.\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\n            address currOwnershipAddr;\n            // If the starting slot exists (i.e. not burned), initialize `currOwnershipAddr`.\n            // `ownership.address` will not be zero, as `start` is clamped to the valid token ID range.\n            if (!ownership.burned) {\n                currOwnershipAddr = ownership.addr;\n            }\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\n                ownership = _ownershipAt(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            // Downsize the array to fit.\n            assembly {\n                mstore(tokenIds, tokenIdsIdx)\n            }\n            return tokenIds;\n        }\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownershipAt(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n}\n"
    },
    "erc721a-upgradeable/contracts/extensions/IERC721AQueryableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721AUpgradeable.sol';\n\n/**\n * @dev Interface of ERC721AQueryable.\n */\ninterface IERC721AQueryableUpgradeable is IERC721AUpgradeable {\n    /**\n     * Invalid query range (`start` >= `stop`).\n     */\n    error InvalidQueryRange();\n\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\n}\n"
    },
    "erc721a-upgradeable/contracts/IERC721AUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721AUpgradeable {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
    },
    "erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../extensions/IERC721AQueryableUpgradeable.sol';\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}